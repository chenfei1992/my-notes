(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{359:function(e,t,r){"use strict";r.r(t);var v=r(42),n=Object(v.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"code"}},[e._v("CODE")]),e._v(" "),r("h2",{attrs:{id:"高性能渲染大数据tree组件"}},[e._v("高性能渲染大数据Tree组件")]),e._v(" "),r("h3",{attrs:{id:"背景"}},[e._v("背景")]),e._v(" "),r("p",[e._v("项目中需要渲染一个5000+节点的树组件，但是在引入element Tree组件之后发现性能非常差，无论是滚动、展开/收起节点还是点击节点卡顿都非常明显，利用performance跑一下性能数据发现到问题所在。Scripting期间除了 Observe 之外，大部分时间都在调用createChildren来创建vue实例")]),e._v(" "),r("h3",{attrs:{id:"优化思路"}},[e._v("优化思路")]),e._v(" "),r("p",[e._v("从上面的分析可以看出引发的性能问题都是因为渲染的节点过多导致，那么要解决这个问题就是尽量减少节点的渲染，然而在业界中与之相类似的解决方案就是虚拟列表 虚拟列表的核心概念就是 根据滚动来控制可视区域渲染的列表 这样一来，就能大幅度减少节点的渲染，提升性能")]),e._v(" "),r("p",[e._v("具体的步骤如下：")]),e._v(" "),r("ol",[r("li",[e._v("将递归结构的tree数据“拍平”，但是保留parent以及child的引用（一方面是为了方便查找子级和父级节点的引用，另一方面是为了方便计算可视区域的list数据）")]),e._v(" "),r("li",[e._v("动态计算滚动区域的高度（很多虚拟长列表的组件都是固定高度的，但是因为这里是tree，需要折叠/展开节点，所以是动态计算高度）")]),e._v(" "),r("li",[e._v("根据可见的高度以及滚动的距离渲染相应的节点\n最简代码实现")])]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/jayZOU/vue-big-tree",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue-big-tree"),r("OutboundLink")],1)]),e._v(" "),r("ol",[r("li",[e._v("整个容器使用相对定位是为了避免在滚动中引起页面回流")]),e._v(" "),r("li",[e._v("phantom 容器为了撑开高度，让滚动条出现")]),e._v(" "),r("li",[e._v("flattenTree 为了拍平 递归结构的tree数据，同时添加level、expand、visibel属性，分别代表节点层级、是否展开、是否可视")]),e._v(" "),r("li",[e._v("contentHeight 动态计算容器的高度，隐藏（收起）节点不应该计算在总高度里面")]),e._v(" "),r("li",[e._v("在flattenTree中保留了针对子级的引用，展开/收起的话，只需要对子级进行显示/隐藏即可")])])])}),[],!1,null,null,null);t.default=n.exports}}]);