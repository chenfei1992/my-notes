<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1.Vue响应式原理 | 笔记</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/my-notes/assets/css/0.styles.01a99bbc.css" as="style"><link rel="preload" href="/my-notes/assets/js/app.d403a9be.js" as="script"><link rel="preload" href="/my-notes/assets/js/2.5b5e09f6.js" as="script"><link rel="preload" href="/my-notes/assets/js/27.bfb04ae5.js" as="script"><link rel="prefetch" href="/my-notes/assets/js/10.bf6a4d4a.js"><link rel="prefetch" href="/my-notes/assets/js/11.20db2e93.js"><link rel="prefetch" href="/my-notes/assets/js/12.fc01f82e.js"><link rel="prefetch" href="/my-notes/assets/js/13.c4b52ead.js"><link rel="prefetch" href="/my-notes/assets/js/14.503326b3.js"><link rel="prefetch" href="/my-notes/assets/js/15.52264397.js"><link rel="prefetch" href="/my-notes/assets/js/16.a712b935.js"><link rel="prefetch" href="/my-notes/assets/js/17.37b85bf7.js"><link rel="prefetch" href="/my-notes/assets/js/18.b5187b72.js"><link rel="prefetch" href="/my-notes/assets/js/19.8ab683c7.js"><link rel="prefetch" href="/my-notes/assets/js/20.dd1bfcb5.js"><link rel="prefetch" href="/my-notes/assets/js/21.6a5a02b7.js"><link rel="prefetch" href="/my-notes/assets/js/22.a4be886a.js"><link rel="prefetch" href="/my-notes/assets/js/23.aee0b122.js"><link rel="prefetch" href="/my-notes/assets/js/24.d7409098.js"><link rel="prefetch" href="/my-notes/assets/js/25.4199201f.js"><link rel="prefetch" href="/my-notes/assets/js/26.44113d15.js"><link rel="prefetch" href="/my-notes/assets/js/28.b40cd87f.js"><link rel="prefetch" href="/my-notes/assets/js/29.089a992e.js"><link rel="prefetch" href="/my-notes/assets/js/3.9d429554.js"><link rel="prefetch" href="/my-notes/assets/js/30.80f23c0e.js"><link rel="prefetch" href="/my-notes/assets/js/31.2dbac603.js"><link rel="prefetch" href="/my-notes/assets/js/4.a4ca32bb.js"><link rel="prefetch" href="/my-notes/assets/js/5.c7df8f88.js"><link rel="prefetch" href="/my-notes/assets/js/6.830c6274.js"><link rel="prefetch" href="/my-notes/assets/js/7.b3bd3833.js"><link rel="prefetch" href="/my-notes/assets/js/8.7ce880e2.js"><link rel="prefetch" href="/my-notes/assets/js/9.29bcbb5e.js">
    <link rel="stylesheet" href="/my-notes/assets/css/0.styles.01a99bbc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/my-notes/" class="home-link router-link-active"><!----> <span class="site-name">笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/my-notes/demoPages/" class="nav-link">
  Demo
</a></div><div class="nav-item"><a href="/my-notes/tools/" class="nav-link">
  工具库
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/my-notes/demoPages/" class="nav-link">
  Demo
</a></div><div class="nav-item"><a href="/my-notes/tools/" class="nav-link">
  工具库
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/my-notes/" aria-current="page" class="sidebar-link">随录</a></li><li><a href="/my-notes/VirtualDom/" class="sidebar-link">虚拟DOM</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>VUE</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/my-notes/vue/" class="sidebar-link">vue 原理分析</a></li><li><a href="/my-notes/vueRouter/" class="sidebar-link">vueRouter</a></li><li><a href="/my-notes/mustKnow/" class="sidebar-link">vue 开发必知</a></li><li><a href="/my-notes/vueInterview/" aria-current="page" class="active sidebar-link">vue 面试题</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>REACT</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>档案</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/my-notes/packages/" class="sidebar-link">原生封装</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>原理分析</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/my-notes/h5Development/" class="sidebar-link">H5 开发技巧</a></li><li><a href="/my-notes/cssModule/" class="sidebar-link">CSS 文档</a></li><li><a href="/my-notes/javascript/" class="sidebar-link">javascript</a></li><li><a href="/my-notes/typeScript/" class="sidebar-link">typeScript</a></li><li><a href="/my-notes/ASM/" class="sidebar-link">ASM.js</a></li><li><a href="/my-notes/%E9%9D%A2%E8%AF%95/" class="sidebar-link">面试</a></li><li><a href="/my-notes/indexedDB/" class="sidebar-link">indexedDB</a></li><li><a href="/my-notes/toolFunction/" class="sidebar-link">toolFunction</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>构建工具</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/my-notes/http/" class="sidebar-link">HTTP</a></li><li><a href="/my-notes/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="sidebar-link">性能优化</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="_1-vue响应式原理">1.Vue响应式原理</h3> <p><img src="https://user-gold-cdn.xitu.io/2019/12/26/16f409e706ab9fb9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p> <h4 id="核心实现类：">核心实现类：</h4> <p>Observer：它的作用是给对象的属性添加getter和setter，用于依赖收集和派发更新
Dep：用于收集当前响应式对象的依赖关系，每个响应式对象包括子对象都拥有一个Dep实例（里面subs是Watcher实例数组），当数据有变更时，会通过dep.notify()通知各个watcher。
Watcher：观察者对象，实例分为渲染watcher（render watcher），计算属性watcher（computed watcher），侦听器watcher（user watcher）三种</p> <h4 id="watcher和dep的关系">Watcher和Dep的关系</h4> <p>watcher中实例化了dep并向dep.subs中添加了订阅者，dep通过notify遍历了dep.subs通知每个watcher更新。</p> <h4 id="依赖收集">依赖收集</h4> <ol><li>initState时，对computed属性初始化时，触发computed watcher依赖收集</li> <li>initState时，对侦听属性初始化时，触发user watcher依赖收集</li> <li>render()的过程，触发render watcher依赖收集</li> <li>re-render时，vm.render()再次执行，会移除所有subs中的watcher的订阅，重新赋值。</li></ol> <h4 id="派发更新">派发更新</h4> <ol><li>组件中对响应的数据进行了修改，触发setter的逻辑</li> <li>调用dep.notify()</li> <li>遍历所有的subs（Watcher实例），调用每一个watcher的update方法。</li></ol> <h4 id="原理">原理</h4> <p>当创建Vue实例时，vue会遍历data选项的属性，利用Object.defineProperty为属性添加getter和setter对数据的读取进行劫持（getter用来依赖收集，setter用来派发更新），并且在内部追踪依赖，在属性被访问和修改时通知变化。
每个组件实例会有相应的watcher实例，会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集，还有computed watcher，user watcher实例），之后依赖项被改动时，setter方法会通知依赖与此data的watcher实例重新计算（派发更新），从而使它关联的组件重新渲染。
一句话总结：
vue.js采用数据劫持结合发布-订阅模式，通过Object.defineProperty来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发响应的监听回调</p> <h3 id="_2-computed的实现原理">2.computed的实现原理</h3> <p>computed本质是一个惰性求值的观察者。
computed内部实现了一个惰性的watcher，也就是computed watcher。computed watcher不会立刻求职，同时持有一个dep实例。
其内部通过this.dirty属性标记计算属性是否需要重新求职。
当computed的依赖状态发生改变时，就会通知这个惰性的watcher，computed watcher通过this.dep.subs.length判断有没有订阅者，有的话会重新计算，然后对比新旧值，如果变化了，会重新渲染。（Vue想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染watcher重新渲染，本质上是一种优化。）
没有的话，仅仅把this.dirty= true.(当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备lazy（懒计算）特性)</p> <h3 id="_3-computed和watch有什么区别及运用场景">3.computed和watch有什么区别及运用场景</h3> <h4 id="区别">区别</h4> <p>computed计算属性：依赖其它属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值。
watch侦听器：更多的是「观察」的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</p> <h4 id="运用场景">运用场景</h4> <p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时，都要重新计算。
当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作（访问一个API），限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p> <h3 id="_4-为什么在vue3-0采用了proxy，抛弃了object-defineproperty">4.为什么在Vue3.0采用了Proxy，抛弃了Object.defineProperty</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>Object.defineProperty本身有一定的监控到数组下标变化的能力，但是在Vue中，从性能/体验的性价比考虑，尤大大就弃用了这个特性（Vue为什么不能检测数组变动）。为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组</p></div> <p>push(); pop(); shift(); unshift(); splice(); sort(); reverse();
由于只针对了以上7种方法进行了hack处理，所以其他数组的属性也是检测不到的，还是具有一定的局限性。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>Object.defineProperty 只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历。Vue2.x里是通过递归 + 遍历data对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历，显然如果能劫持一个完整的对象才是更好的选择。
Proxy可以劫持整个对象，并返回一个新的对象。Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</p></div> <h3 id="_5-vue中的key到底有什么用？">5.Vue中的key到底有什么用？</h3> <p>key是给每一个vnode的唯一id，依靠key，我们的diff操作可以更准确、更快速（对于简单列表页渲染来说diff节点也更快，但会产生一些隐藏的副作用，比如可能不会产生过渡效果，或者在某些节点有绑定数据（表单）状态，会出现状态错位）
diff算法的过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的key与旧节点进行比对，从而找到相应旧节点。
更准确：因为带key就不是就地复用了，在sameNode函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确，如果不加key，会导致之前节点的状态被保留下来，会产生一系列的bug。
更快速：key的唯一性可以被Map数据结构充分利用，相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1),源码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createKeyToOldIdx</span><span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span>beginIdx<span class="token punctuation">,</span>endIdx</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token punctuation">,</span> key<span class="token punctuation">;</span>
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> beginIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    key <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> map
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_6-谈一谈nexttick的原理">6.谈一谈nextTick的原理</h3> <h4 id="js运行机制">JS运行机制</h4> <p>JS执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：
1.所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）
2.主线程之外，还存在一个“任务队列”(task queue)。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件
3.一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4.主线程不断重复上面的第三步。
<img src="https://user-gold-cdn.xitu.io/2019/12/26/16f409e91d0ff121?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">
主线程的执行过程就是一个tick，而所有的异步结果都是通过“任务队列”来调度。消息队列中存放的是一个个的任务（task）。规范中规定task分为两大类，分别是macro task和micro task，并且每个macro task结束后，都要清空所有的micro task。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span>macroTask <span class="token keyword">of</span> macroTaskQueue<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 1. Handle current MACRO-TASK</span>
  <span class="token function">handleMacroTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 2. Handle all MICRO-TASK</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>microTask <span class="token keyword">of</span> microTaskQueue<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">handleMicroTask</span><span class="token punctuation">(</span>microTask<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在浏览器环境中：
常见的macro task有setTimeout、MessageChannel、postMessage、setImmediate
常见的micro task有MutationObsever和Promise.then</p> <h4 id="异步更新队列">异步更新队列</h4> <p>可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。
然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。
Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。
在 vue2.5 的源码中，macrotask 降级的方案依次是：setImmediate、MessageChannel、setTimeout
vue的nextTick方法的实现原理：</p> <ol><li>vue用异步队列的方法来控制DOM更新和nextTick回调先后执行</li> <li>microtask因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕</li> <li>考虑兼容问题，vue做了microtask向macrotask的降级方案</li></ol> <h3 id="_7-vue是如何对数组方法进行变异的？">7. vue是如何对数组方法进行变异的？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;push&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;pop&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;shift&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;unshift&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;splice&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;sort&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;reverse&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span>method<span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token function">mutator</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__<span class="token punctuation">;</span>
    <span class="token keyword">let</span> inserted<span class="token punctuation">;</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">&quot;push&quot;</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">&quot;unshift&quot;</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token string">&quot;splice&quot;</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token class-name">Observer</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">observeArray</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">observeArray</span><span class="token punctuation">(</span><span class="token parameter">items</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>l <span class="token operator">=</span> item<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>简单来说，Vue通过原型拦截的方式重写了数组的7个方法，首先获取到这个数组的ob，也就是它的Observer对象，如果有新的值，就调用observeArray对新的值进行监听，然后手动调用notify，通知render watcher，执行update</p> <h3 id="_8-vue组件data为什么必须是函数？">8.Vue组件data为什么必须是函数？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>实例中，data可以直接是一个对象，为什么在vue组件中，data必须是一个函数
</code></pre></div><p>因为组件是可以复用的，JS里对象是引用关系，如果组件data是一个对象，那么子组件中的data属性值会互相污染，产生副作用。
所以一个组件的data选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue的实例是不会被复用的，因此不存在以上问题。</p> <h3 id="_9-谈谈vue事件机制，手写-on-off-emit-once">9.谈谈Vue事件机制，手写$on,$off,$emit,$once</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>Vue 事件机制 本质上就是一个 发布-订阅 模式的实现。</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Vue</span><span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 事件通道调度中心</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_events <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">$on</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span>fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      event<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>fn<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
      <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">$once</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span>fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span>on<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    on<span class="token punctuation">.</span>fn <span class="token operator">=</span> fn<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span>on<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span>
  <span class="token function">$off</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span>fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_events <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      event<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>fn<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> cbs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>cbs<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> cb<span class="token punctuation">;</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> cbs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      cb <span class="token operator">=</span> cbs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>cb <span class="token operator">===</span> fn <span class="token operator">||</span> cb<span class="token punctuation">.</span>fn <span class="token operator">===</span> fn<span class="token punctuation">)</span><span class="token punctuation">{</span>
        cbs<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">$emit</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> cbs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>cbs<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      cbs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        args <span class="token operator">?</span> <span class="token function">item</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">item</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_10-说说vue的渲染过程">10. 说说Vue的渲染过程</h3> <p><img src="https://user-gold-cdn.xitu.io/2019/12/26/16f40a08cac6d3cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p> <ol><li>调用compile函数，生成render函数字符串，编译过程如下：</li></ol> <ul><li>parse函数解析template，生成ast（抽象语法树）</li> <li>optimize函数优化静态节点（标记不需要每次都更新的内容，diff算法会直接跳过静态节点，从而减少比较的过程，优化了patch的性能）</li> <li>generate函数生成render函数字符串</li></ul> <ol start="2"><li>调用new Watcher函数，监听数据的变化，当数据发生变化时，Render函数执行生成vnode对象</li> <li>调用patch方法，对比新旧vnode对象，通过DOM diff算法，添加、修改、删除真正的DOM元素</li></ol> <h3 id="_11-聊聊keep-alive的实现原理和缓存策略">11.聊聊keep-alive的实现原理和缓存策略</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;keep-alive&quot;</span><span class="token punctuation">,</span>
  abstract<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment">// 抽象组件属性 ,它在组件实例建立父子关系的时候会被忽略,发生在 initLifecycle 的过程中</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    include<span class="token operator">:</span> patternTypes<span class="token punctuation">,</span>   <span class="token comment">//被缓存组件</span>
    exclude<span class="token operator">:</span> patternTypes<span class="token punctuation">,</span>   <span class="token comment">// 不被缓存组件</span>
    max<span class="token operator">:</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span>Number<span class="token punctuation">]</span>    <span class="token comment">//  指定缓存大小</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//  缓存</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                 <span class="token comment">// 缓存的VNode的键</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">destroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// 删除所有缓存</span>
      <span class="token function">pruneCacheEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">,</span>key<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 监听缓存/不缓存组件</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">&quot;include&quot;</span><span class="token punctuation">,</span><span class="token parameter">val</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">pruneCache</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token parameter">name</span> <span class="token operator">=&gt;</span> <span class="token function">matches</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">&quot;exclude&quot;</span><span class="token punctuation">,</span><span class="token parameter">val</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">pruneCache</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token parameter">name</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span><span class="token function">matches</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> slot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span>default<span class="token punctuation">;</span>
    <span class="token keyword">const</span> vnode<span class="token operator">:</span> VNode <span class="token operator">=</span> <span class="token function">getFirstComponentChild</span><span class="token punctuation">(</span>slot<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> componentOptions<span class="token operator">:</span> <span class="token operator">?</span>VNodeComponentOptions <span class="token operator">=</span> vnode <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span>componentOptions<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>componentOptions<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// name不在include中或者在exclude中 直接返回vnode</span>
      <span class="token comment">// check pattern</span>
      <span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token operator">?</span>string <span class="token operator">=</span> <span class="token function">getComponentName</span><span class="token punctuation">(</span>componentOptions<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span>include<span class="token punctuation">,</span>exclude<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>include <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>name <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">matches</span><span class="token punctuation">(</span>include<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>exclude <span class="token operator">&amp;&amp;</span> name <span class="token operator">&amp;&amp;</span> <span class="token function">matches</span><span class="token punctuation">(</span>exclude<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> vnode<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span>cache<span class="token punctuation">,</span>keys<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
      <span class="token comment">// 获取键，优先获取组件的name字段，否则是组件的tag</span>
      <span class="token keyword">const</span> key<span class="token operator">:</span> <span class="token operator">?</span>string <span class="token operator">=</span> vnode<span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> componentOptions<span class="token punctuation">.</span>Ctor<span class="token punctuation">.</span>cid <span class="token operator">+</span> 
      <span class="token punctuation">(</span>componentOptions<span class="token punctuation">.</span>tag <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">::</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>componentOptions<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span> <span class="token operator">:</span> vnode<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
      <span class="token comment">// 命中缓存，直接从缓存拿vnode的组件实例，并且重新调整了key的顺序放在了最后一个</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>componentInstance<span class="token punctuation">;</span>
        <span class="token function">remove</span><span class="token punctuation">(</span>keys<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        keys<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 不命中缓存，把vnode设置进缓存</span>
      <span class="token keyword">else</span><span class="token punctuation">{</span>
        cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> vnode<span class="token punctuation">;</span>
        keys<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果配置了max并且缓存的长度超过了this.max,还要从缓存中删除第一个</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>max <span class="token operator">&amp;&amp;</span> keys<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token function">pruneCacheEntry</span><span class="token punctuation">(</span>cache<span class="token punctuation">,</span>keys<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>keys<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>_vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// keepAlive标记位</span>
      vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keepAlive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> vnode <span class="token operator">||</span> <span class="token punctuation">(</span>slot <span class="token operator">&amp;&amp;</span> slot<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="原理-2">原理</h5> <ol><li>获取keep-alive包裹着的第一个子组件对象及其组件名</li> <li>根据设定的include/exclude（如果有）进行条件匹配，决定是否缓存。不匹配，直接返回组件实例</li> <li>根据组件ID和tag生成缓存key，并在缓存对象中查找是否已缓存过该组件实例。如果存在，直接取出缓存值并更新该key在this.keys中的位置（更新key的位置是实现LRU置换策略的关键）</li> <li>在this.cache对象中存储该组件实例并保存key值，之后检查缓存的实例数量是否超过max的设置值，超过则根据LRU置换策略删除最近最久未使用的实例（即是下标为0的那个key）</li> <li>最后组件实例的keepAlive属性设置为true，这个在渲染和执行被包裹的钩子函数会用到，这里不细说</li></ol> <h5 id="lru-缓存淘汰算法">LRU 缓存淘汰算法</h5> <p>LRU（Least recently used）算法根据数据的历史访问记录来进行淘汰数据,其核心思想是“如果数据最近被访问过,那么将来被访问的几率也更高”。
keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0]</p> <h3 id="_12-vm-set-实现原理是什么">12. vm.$set()实现原理是什么</h3> <p>受现代JavaScript的限制（而且Object.observe也已经被废弃），vue无法检测到对象属性的添加或删除。
由于vue会在初始化实例时对属性执行getter/setter转化，所以属性必须在data对象上存在才能让vue将它转换为响应式的。
对于已经创建的实例，vue不允许动态添加根级别的响应式属性。但是，可以使用Vue.set(object,propertyName,value) 方法向嵌套对象添加响应式属性
那么Vue内部是如何解决对象新增属性不能响应的问题的呢？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token operator">|</span> Object<span class="token punctuation">,</span>key<span class="token operator">:</span> any<span class="token punctuation">,</span>val<span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span>any <span class="token punctuation">{</span>
  <span class="token comment">// target 为数组  </span>
  <span class="token keyword">if</span><span class="token function"> </span><span class="token punctuation">(</span><span class="token parameter">Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token function"> isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误    </span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token comment">// 利用数组的splice变异方法触发响应式    </span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  
    <span class="token comment">// target为对象, key在target或者target.prototype上 且必须不能在 Object.prototype 上,直接赋值  </span>
    <span class="token keyword">if</span><span class="token function"> </span><span class="token punctuation">(</span><span class="token parameter">key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
      target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>    
      <span class="token keyword">return</span> val<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token comment">// 以上都不成立, 即开始给target创建一个全新的属性  </span>
    <span class="token comment">// 获取Observer实例  </span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span><span class="token function"> </span><span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__<span class="token punctuation">;</span>  
    <span class="token comment">// target 本身就不是响应式数据, 直接赋值  </span>
    <span class="token keyword">if</span><span class="token function"> </span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">!</span>ob</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
      target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>    
      <span class="token keyword">return</span> val<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token comment">// 进行响应式处理  defineReactive(ob.value, key, val);  ob.dep.notify();  </span>
    <span class="token keyword">return</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li>如果目标是数组，使用vue实现的变异方法splice实现响应式</li> <li>如果目标是对象，判断属性存在，即为响应式，直接赋值</li> <li>如果target本身就不是响应式，直接赋值</li> <li>如果属性不是响应式，则调用defineReactive方法进行响应式处理</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/my-notes/mustKnow/" class="prev">
        vue 开发必知
      </a></span> <span class="next"><a href="/my-notes/kbone/">
        kbone
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/my-notes/assets/js/app.d403a9be.js" defer></script><script src="/my-notes/assets/js/2.5b5e09f6.js" defer></script><script src="/my-notes/assets/js/27.bfb04ae5.js" defer></script>
  </body>
</html>
