<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>笔记</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/my-notes/assets/css/0.styles.01a99bbc.css" as="style"><link rel="preload" href="/my-notes/assets/js/app.a5c99926.js" as="script"><link rel="preload" href="/my-notes/assets/js/2.5b5e09f6.js" as="script"><link rel="preload" href="/my-notes/assets/js/5.8b4ead99.js" as="script"><link rel="prefetch" href="/my-notes/assets/js/10.6e5215f1.js"><link rel="prefetch" href="/my-notes/assets/js/11.cc109dba.js"><link rel="prefetch" href="/my-notes/assets/js/12.4ec8bf0b.js"><link rel="prefetch" href="/my-notes/assets/js/13.c4b52ead.js"><link rel="prefetch" href="/my-notes/assets/js/14.76dd2d55.js"><link rel="prefetch" href="/my-notes/assets/js/15.2145b756.js"><link rel="prefetch" href="/my-notes/assets/js/16.91470adf.js"><link rel="prefetch" href="/my-notes/assets/js/17.7474600e.js"><link rel="prefetch" href="/my-notes/assets/js/18.7b96dcc6.js"><link rel="prefetch" href="/my-notes/assets/js/19.8ce68178.js"><link rel="prefetch" href="/my-notes/assets/js/20.91376043.js"><link rel="prefetch" href="/my-notes/assets/js/21.7127a079.js"><link rel="prefetch" href="/my-notes/assets/js/22.f15d389d.js"><link rel="prefetch" href="/my-notes/assets/js/23.9603810a.js"><link rel="prefetch" href="/my-notes/assets/js/24.46bb4888.js"><link rel="prefetch" href="/my-notes/assets/js/25.6a64171b.js"><link rel="prefetch" href="/my-notes/assets/js/26.76c13837.js"><link rel="prefetch" href="/my-notes/assets/js/27.342ea004.js"><link rel="prefetch" href="/my-notes/assets/js/28.659c9545.js"><link rel="prefetch" href="/my-notes/assets/js/29.089a992e.js"><link rel="prefetch" href="/my-notes/assets/js/3.9d429554.js"><link rel="prefetch" href="/my-notes/assets/js/30.1fd0e1b6.js"><link rel="prefetch" href="/my-notes/assets/js/31.2dbac603.js"><link rel="prefetch" href="/my-notes/assets/js/4.a4ca32bb.js"><link rel="prefetch" href="/my-notes/assets/js/6.737b8a35.js"><link rel="prefetch" href="/my-notes/assets/js/7.b3bd3833.js"><link rel="prefetch" href="/my-notes/assets/js/8.8aab4de1.js"><link rel="prefetch" href="/my-notes/assets/js/9.8d55680f.js">
    <link rel="stylesheet" href="/my-notes/assets/css/0.styles.01a99bbc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/my-notes/" aria-current="page" class="home-link router-link-exact-active router-link-active"><!----> <span class="site-name">笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/my-notes/demoPages/" class="nav-link">
  Demo
</a></div><div class="nav-item"><a href="/my-notes/tools/" class="nav-link">
  工具库
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/my-notes/demoPages/" class="nav-link">
  Demo
</a></div><div class="nav-item"><a href="/my-notes/tools/" class="nav-link">
  工具库
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/my-notes/" aria-current="page" class="active sidebar-link">随录</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/my-notes/#虚拟列表" class="sidebar-link">🐏 虚拟列表</a></li><li class="sidebar-sub-header"><a href="/my-notes/#mvvm的流程分析" class="sidebar-link">🐏 MVVM的流程分析</a></li><li class="sidebar-sub-header"><a href="/my-notes/#从多线程到-eventloop-全面梳理" class="sidebar-link">🐏 从多线程到 EventLoop 全面梳理</a></li><li class="sidebar-sub-header"><a href="/my-notes/#generator-函数暂停恢复执行原理" class="sidebar-link">🐏 Generator 函数暂停恢复执行原理</a></li><li class="sidebar-sub-header"><a href="/my-notes/#async-await" class="sidebar-link">🐏 async/await</a></li><li class="sidebar-sub-header"><a href="/my-notes/#实现高难度加载、吸顶、触底" class="sidebar-link">🐏 实现高难度加载、吸顶、触底</a></li></ul></li><li><a href="/my-notes/VirtualDom/" class="sidebar-link">虚拟DOM</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VUE</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>REACT</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>档案</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/my-notes/packages/" class="sidebar-link">原生封装</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>原理分析</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/my-notes/h5Development/" class="sidebar-link">H5 开发技巧</a></li><li><a href="/my-notes/cssModule/" class="sidebar-link">CSS 文档</a></li><li><a href="/my-notes/javascript/" class="sidebar-link">javascript</a></li><li><a href="/my-notes/typeScript/" class="sidebar-link">typeScript</a></li><li><a href="/my-notes/ASM/" class="sidebar-link">ASM.js</a></li><li><a href="/my-notes/%E9%9D%A2%E8%AF%95/" class="sidebar-link">面试</a></li><li><a href="/my-notes/indexedDB/" class="sidebar-link">indexedDB</a></li><li><a href="/my-notes/toolFunction/" class="sidebar-link">toolFunction</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>构建工具</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/my-notes/http/" class="sidebar-link">HTTP</a></li><li><a href="/my-notes/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="sidebar-link">性能优化</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2262624164,2554133709&amp;fm=26&amp;gp=0.jpg" alt="An image"></p> <h2 id="虚拟列表">🐏 虚拟列表</h2> <p><code>虚拟列表</code>其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能</p> <p>假设有 1 万条记录需要同时渲染，我们屏幕的可见区域的高度为 500px，而列表项的高度为 50px,则此时我们在屏幕中最多智能看到 10 个列表项，那么在首次渲染的时候，我们只需要加载 10 条即可。
可查看项目 virtual-listview
[高性能渲染大数据Tree组件]</p> <h2 id="mvvm的流程分析">🐏 MVVM的流程分析</h2> <p>在Vue的MVVM设计中，我们主要针对Compile（模板编译）、Observer（数据劫持）、Watcher（数据监听）和 Dep（发布订阅）几部分来实现
<img src="/my-notes/assets/img/mvvm.bfab5ed0.jpg" alt="mvvm"></p> <h2 id="从多线程到-eventloop-全面梳理">🐏 从多线程到 EventLoop 全面梳理</h2> <p>进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。进程之间相互独立，任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。CPU 使用时间片轮进度算法来实现同时运行多个进程。
线程就好比车间里的工人，一个进程可以包括多个线程，多个线程共享进程资源</p> <h4 id="cpu、进程、线程之间的关系">CPU、进程、线程之间的关系</h4> <ul><li>进程 是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li></ul> <ul><li>线程 是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li> <li>不同进程之间也可以通信，不过代价较大</li></ul> <ul><li>单线程与多线程，都是指在一个进程内的单和多</li></ul> <h4 id="浏览器是多进程的">浏览器是多进程的</h4> <p>对于计算机来说，每一个应用程序都是一个进程，而每一个应用程序都会有很多的功能模块，这些功能模块实际上是通过子进程来实现的。对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。
而对于浏览器来说，浏览器就是多进程的，我在 Chrome 浏览器中打开了多个 tab，每个 tab 页，就是一个独立的进程</p> <h5 id="浏览器包含了哪些进程">浏览器包含了哪些进程</h5> <ul><li>主进程
<ul><li>协调控制其他子进程（创建、销毁）</li> <li>浏览器界面显示，用户交互，前进、后退、收藏</li> <li>将渲染进程得到的内存中的 Bitmap，绘制到用户界面上</li> <li>处理不可见操作，网络请求，文件访问等</li></ul></li></ul> <ul><li><p>第三方插件进程</p> <ul><li>每种类型的插件对应一个进程，仅当使用该插件时才创建</li></ul></li> <li><p>GPU 进程</p> <ul><li>用于 3D 绘制等</li></ul></li> <li><p>渲染进程，就是我们说的浏览器内核</p> <ul><li>负责页面渲染，脚本执行，事件处理等</li> <li>每个 tab 页一个渲染进程
对于普通的前端操作来说，最重要的是渲染进程，也就是我们常说的浏览器内核</li></ul></li></ul> <h5 id="浏览器内核（渲染进程）">浏览器内核（渲染进程）</h5> <p>渲染进程也是多线程的</p> <ul><li>GUI 渲染线程
<ul><li>负责渲染页面，布局和绘制</li> <li>页面需要重绘和回流时，该线程就会执行</li> <li>与 js 引擎线程互斥，防止渲染结果不可预期</li></ul></li> <li>JS 引擎线程
<ul><li>负责处理解析和执行 JavaScript 脚本程序</li> <li>只有一个 js 引擎线程（单线程）</li> <li>与 GUI 渲染线程互斥，防止渲染结果不可预期</li></ul></li> <li>定时触发器线程
<ul><li>setInterval 与 setTimeout 所在线程</li> <li>定时任务并不是由 js 引擎计时的，是由定时触发线程来计时的</li> <li>计时完毕后，通知事件触发线程</li></ul></li> <li>异步 http 请求线程
<ul><li>浏览器有一个单独的线程用于处理 AJAX 请求</li> <li>当请求完成时，若有回调函数，通知事件触发线程</li></ul></li></ul> <h5 id="为什么-javascript-是单线程的">为什么 JavaScript 是单线程的</h5> <p>在创建 JavaScript 这门语言时，多进程多线程的架构并不流行，硬件支持不好。
其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高
而且，如果同时操作 DOM，在多线程不加锁的情况下最终会导致 DOM 渲染的结果不可预期</p> <h5 id="为什么-gui-渲染线程与-js-引擎线程互斥">为什么 GUI 渲染线程与 JS 引擎线程互斥</h5> <p>这是由于 js 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面（即 JS 线程和 UI 线程同时运行），那么渲染线程前后获得的元素就可能不一致了。
因此，为了防止渲染出现不可预期的结果，浏览器设定 GUI 渲染线程和 JS 引擎线程为互斥关系，当 JS 引擎线程执行时 GUI 渲染线程会被挂起，GUI 更新则会被保存在一个队列中等待 JS 引擎线程空闲时立即被执行。</p> <h4 id="从-event-loop-看-js-的运行机制">从 Event Loop 看 JS 的运行机制</h4> <p>概念：</p> <ul><li>JS 分为同步任务和异步任务</li> <li>同步任务都在 JS 引擎线程上执行，形成一个执行栈</li> <li>事件触发线程管理一个任务队列，异步任务触发条件达成，将回调事件放到任务队列中</li> <li>执行栈中所有同步任务执行完毕，此时 js 引擎线程空闲，系统会读取任务队列，将可运行的异步任务回调事件添加到执行栈中，开始执行</li></ul> <h4 id="运行-settimeout、setinterval、xhr、fetch">运行 setTimeout、setInterval、XHR、fetch</h4> <p>当代码执行到 setTimeout/setInterval 时，实际上是 JS 引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件，而定时触发器线程在接收到这个消息后，会在等待的时间后，将回调事件放入到由事件触发线程所管理的事件队列中。</p> <p>当代码执行到 XHR/fetch 时，实际上是 JS 引擎线程通知异步 http 请求线程，发送一个网络请求，并制定请求完成后的回调事件，而异步 http 请求线程在接收到这个消息后，会在请求成功后，将回调事件放入到由事件触发线程所管理的事件队列中。</p> <p>当我们的同步任务执行完，JS 引擎线程会询问事件触发线程，在事件队列中是否有待执行的回调函数，如果有就会加入到执行栈中交给 JS 引擎线程执行</p> <p>总结：</p> <ul><li>JS 引擎线程只执行执行栈中的事件</li> <li>执行栈中的代码执行完毕，就会读取事件队列中的事件</li> <li>事件队列中的回调事件，是由各自线程插入到事件队列中的</li> <li>如此循环</li></ul> <h2 id="generator-函数暂停恢复执行原理">🐏 Generator 函数暂停恢复执行原理</h2> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协成。</p></div> <p>协程是一种比线程更加轻量级的存在。普通线程是抢先式的，会争夺 cpu 资源，而协程是合作的，可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。</p> <ul><li>1.协程 A 开始执行</li> <li>2.协程 A 执行到某个阶段，进入暂停，执行权转移到协程 B</li> <li>3.协程 B 执行完成或暂停，将执行权交还 A</li> <li>4.协程 A 恢复执行
协程遇到<code>yield命令</code>就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除 yield 命令，简直一模一样。</li></ul> <h4 id="执行器">执行器</h4> <p>通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器，<code>co模块</code>就是一个著名的执行器
Generator 是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。两种方法可以做到这一点：</p> <ul><li>1.回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权</li> <li>2.Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权
一个基于 Promise 对象的简单自动执行器</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    result<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回promise对象</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'response1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'response2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">run</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码中，只要 Generator 函数还没执行到最后异步，next 函数就调用自身，以此实现自动执行。通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也加强了代码的可读性。</p> <h2 id="async-await">🐏 async/await</h2> <p>ES7 中引入了 async/await，这种方式能够彻底告别执行器和生成器，实现更加直观简洁的代码。根据 MDN 定义，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。可以说 async 是 Generator 函数的语法糖，并对 Generator 函数进行了改进
前文中的代码，用 async 实现是这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> response1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'response1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> response2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'response2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>async 函数对 Generator 函数的改进，体现在以下四点：</p> <ul><li>1.内置执行器。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。</li> <li>2.更好的语义。async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li> <li>3.更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li> <li>4.返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。</li></ul> <h2 id="实现高难度加载、吸顶、触底">🐏 实现高难度加载、吸顶、触底</h2> <p><code>IntersectionObserver</code>接口，提供了一种异步观察 目标元素与其祖先元素或顶级文档视窗（viewport）交叉状态的方法，祖先元素与视窗（viewport）被称为根（root）；
<code>IntersectionObserver</code>翻译为『交叉观察者』，它的任务就是监听目标元素跟指定父元素（用户可指定，默认为 viewport）是否在发生交叉行为，简单理解就是监听目标元素是否进入或者离开了指定父元素的内部</p> <h4 id="_1-构造函数">1.构造函数</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_2-callback">2.callback</h4> <p>发生交叉的回调，接受一个 entries 参数，返回当前已监听并且发生了交叉的目标集合</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token parameter">entries</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>item 里面包含哪些常用属性</p> <table><thead><tr><th>属性</th> <th>说明</th></tr></thead> <tbody><tr><td>boundingClientRect</td> <td>空间信息</td></tr> <tr><td>intersectionRatio</td> <td>元素可见区域的占比</td></tr> <tr><td>isIntersecting</td> <td>字面理解为是否正在交叉，可用做判断元素是否可见</td></tr> <tr><td>target</td> <td>目标节点，就跟 event.target 一样</td></tr></tbody></table> <p>注意：页面初始化的时候会触发一次 callback，entries 为所有已监听的目标集合</p> <h4 id="_3-options">3.options</h4> <table><thead><tr><th>属性</th> <th>说明</th></tr></thead> <tbody><tr><td>root</td> <td>指定父元素，默认为视窗</td></tr> <tr><td>rootMargin</td> <td>触发交叉的偏移值，默认为『0px 0px 0px 0px』(上左下右，正数为向外扩散，负数则向内收缩)</td></tr></tbody></table> <p>如果设置 rootMargin 为『20px 0px 30px 30px』,那么元素未达到视窗时，就已经切换为可见状态了</p> <h4 id="_4-常用方法">4.常用方法</h4> <table><thead><tr><th>名称</th> <th>说明</th> <th>参数</th></tr></thead> <tbody><tr><td>observe</td> <td>开始监听一个目标元素</td> <td>节点</td></tr> <tr><td>unobserve</td> <td>停止监听一个目标元素</td> <td>节点</td></tr> <tr><td>takeRecords</td> <td>返回所有监听的目标元素结合</td> <td></td></tr> <tr><td>disconnect</td> <td>停止所有监听</td> <td></td></tr></tbody></table> <h3 id="_02-简单例子">02 简单例子</h3> <p>1.假设页面上有一个 class=&quot;box&quot;的盒子且父元素为视窗</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.box'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token parameter">entries</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> tips <span class="token operator">=</span> item<span class="token punctuation">.</span>isIntersecting
      <span class="token operator">?</span> <span class="token string">'进入了父元素的内部'</span>
      <span class="token operator">:</span> <span class="token string">'离开了父元素的内部'</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tips<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>box<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 监听一个box</span>
</code></pre></div><p>2.假设页面上有多个 class=&quot;box&quot;的盒子且父元素为视窗：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'.box'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token parameter">entries</span> <span class="token operator">=&gt;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">发生交叉行为，目标元素有</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>entries<span class="token punctuation">.</span>length<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">个</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
box<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 监听多个box</span>
</code></pre></div><p>3.指定父元素
假设 html 如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;parent&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;child&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// 开始监听</span>
<span class="token keyword">let</span> child <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.child'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>
  <span class="token parameter">entries</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>isIntersecting <span class="token operator">?</span> <span class="token string">'可见'</span> <span class="token operator">:</span> <span class="token string">'不可见'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    root<span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.parent'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开始监听child</span>
</code></pre></div><h3 id="_03-实际应用">03 实际应用</h3> <p>1.图片懒加载
以前都是监听浏览器滚动，然后遍历拿到每个图片的空间信息，然后判断一些位置信息从而进行图片加载；而现在只需要交给交叉观察者去做</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> images <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'img.lazyload'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token parameter">entries</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>isIntersecting<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      item<span class="token punctuation">.</span>target<span class="token punctuation">.</span>src <span class="token operator">=</span> item<span class="token punctuation">.</span>target<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>origin<span class="token punctuation">;</span> <span class="token comment">// 开始加载图片</span>
      observer<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 停止监听已开始加载的图片</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
images<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>2.触底
我们在列表底部放一个参照元素，然后让交叉观察者去监听；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 数据列表</span>
<span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>index<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>    <span class="token comment">// 多个 li</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
<span class="token comment">// 参照元素</span>
<span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;reference&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token parameter">entries</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> item <span class="token operator">=</span> entries<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 拿第一个就行，反正只有一个</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>isIntersecting<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;滚动到了底部，开始请求数据&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;.reference&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 监听参照元素</span>
</code></pre></div><p>3.吸顶
实现元素吸顶的方式有很多种，如 css 的 position:sticky,兼容性较差；如果用交叉观察者实现也很方便，同样也要发一个参照元素</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>    <span class="token comment">// 多个li</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
<span class="token comment">// scss</span>
ul <span class="token punctuation">{</span>
  li <span class="token punctuation">{</span>
    <span class="token operator">&amp;</span><span class="token punctuation">.</span>show <span class="token punctuation">{</span>
      <span class="token comment">// 默认从左边进来</span>
      animation<span class="token operator">:</span> left <span class="token number">1</span>s ease<span class="token punctuation">;</span>
      <span class="token comment">// 偶数从右边进来</span>
      <span class="token operator">&amp;</span><span class="token operator">:</span>nth<span class="token operator">-</span><span class="token function">child</span><span class="token punctuation">(</span><span class="token parameter"><span class="token number">2n</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        animation<span class="token operator">:</span> right <span class="token number">1</span>s ease<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
@keyframes left <span class="token punctuation">{</span>
  <span class="token keyword">from</span> <span class="token punctuation">{</span>
    opacity<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    transform<span class="token operator">:</span> <span class="token function">translate</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">20</span>px<span class="token punctuation">,</span><span class="token number">20</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// right动画改成20px，20px即可</span>
  <span class="token punctuation">}</span>
  to <span class="token punctuation">{</span>
    opacity<span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 监听</span>
<span class="token keyword">let</span> list <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">&quot;ul li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span><span class="token parameter">entries</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>isIntersecting<span class="token punctuation">)</span><span class="token punctuation">{</span>
      item<span class="token punctuation">.</span>target<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'show'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 增加show类名</span>
      observer<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 移除监听</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/my-notes/VirtualDom/">
        虚拟DOM
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/my-notes/assets/js/app.a5c99926.js" defer></script><script src="/my-notes/assets/js/2.5b5e09f6.js" defer></script><script src="/my-notes/assets/js/5.8b4ead99.js" defer></script>
  </body>
</html>
